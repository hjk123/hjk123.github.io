

## 对象，消息，运行期

1. ios中属性关键字copy,strong,readonly,nonatomic 是为编译器生成读取方法而准备的，属性定义的关键字不同，编译器生成的读取方法(getter,setter)不同。所以如果自己实现了读取方法，读取方法的实现也应该符合这些关键字的定义。
2. 在对象内部尽量直接访问实例变量，由于不经过方法派发，所以直接访问实例变量的速度当然比较快。
3. objc_msgSend的作用，这是一个c语言级别的函数，通常叫做消息传递，正是有个这样的函数，oc这门语言才能称为是一门动态的语言，调用某个函数，就是给某个对象发送一个消息，该对象首先会去找到该对象所属的类型，在根据该类型的方法列表来找到相应的方法，一个消息包含了接受者和选择子，接受者就是某个对象，选择子就是方法的名字。
4. ARC 的实质就是编译器在编译代码的时候在适当的位置加[object  retain]和[obejct release]等语句，当创建对象的时候，对象的引用计数会自动加1，对该对象做一些操作后，编译器会自动会帮我们在后面加上[object release]语句。还有就是当我们强引用某个对象的时候，编译器会将该对象的引用计数加1，当持有对象被释放的时候，那么编译器就是将被持有对象的引用计数减1，这些加减操作都是有ARC在编译代码的时候自动完成的，不需要我们去手动管理内存了。

5. 内存管理几个比较重要的点：引用计数:对象创建的时候该对象的引用计数大于等于1，某对象如果强引用该对象，该对象的引用计数加1，某对象如果只是弱引用，该对象的引用计数不会改变，但是该对象的属性和方法其都会有访问权限。autorelease(自动释放池):调用自动释放方法的时候，表示该对象的引用计数不会立即减1，而是在下一次事件循环时递减。引用环(retain cycle):也就是几个对象呈环状互相强引用，导致每个对象的引用计数都无法为0，无法被系统回收，导致内存泄露。如果苹果用的也是垃圾回收器来回收垃圾对象，那么整个循环对象，也被成为孤岛会被垃圾回收器回收，但是苹果用了引用计数来进行内存管理，那么解决引用环的方法只有是将其中的一个强引用变成弱引用，或者外界其他命令强行将其中的一个对象不再强引用其他对象。
6. 块(block)和大中枢派发(Grand Central Dispath) :block的学习。block分为三种类型:stackBlock(内存分配在栈上面) globalBlock(内存分配在全局区域) heapBlock(内存分配在堆里面)  全局block 不会访问任何block范围外面的变量，存放在栈上面的block当函数调用结束的时候，他就会被block所在的地址就会被覆盖掉，存放在堆上面的block它的销毁方式和实力对象一样，存在引用计数，当block的引用计数为0的时候才会被系统回收。但是在ARC开启的情况下，存放在栈中的block 会自动存放在堆中，就只会存在两种类型的block,globalblock 和 heapblock.